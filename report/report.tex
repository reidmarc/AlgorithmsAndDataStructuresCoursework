% #######################################
% ########### FILL THESE IN #############
% #######################################
\def\mytitle{Coursework Report}
\def\mykeywords{C Sharp, WPF, Draughts, Checkers, Marc, Reid}
\def\myauthor{Marc Reid}
\def\contact{03001588@live.napier.ac.uk}
\def\mymodule{Algorithms and Data Structures (SET09117)}
% #######################################
% #### YOU DON'T NEED TO TOUCH BELOW ####
% #######################################
\documentclass[10pt, a4paper]{article}
\usepackage[a4paper,outer=1.5cm,inner=1.5cm,top=1.75cm,bottom=1.5cm]{geometry}
\twocolumn
\usepackage{graphicx}
\graphicspath{{./images/}}
%colour our links, remove weird boxes
\usepackage[colorlinks,linkcolor={black},citecolor={blue!80!black},urlcolor={blue!80!black}]{hyperref}
%Stop indentation on new paragraphs
\usepackage[parfill]{parskip}
%% Arial-like font
\IfFileExists{uarial.sty}
{
    \usepackage[english]{babel}
    \usepackage[T1]{fontenc}
    \usepackage{uarial}
    \renewcommand{\familydefault}{\sfdefault}
}{
    \GenericError{}{Couldn't find Arial font}{ you may need to install 'nonfree' fonts on your system}{}
    \usepackage{lmodern}
    \renewcommand*\familydefault{\sfdefault}
}
%Napier logo top right
\usepackage{watermark}
%Lorem Ipusm dolor please don't leave any in you final report ;)
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}
%give us the Capital H that we all know and love
\usepackage{float}
%tone down the line spacing after section titles
\usepackage{titlesec}
%Cool maths printing
\usepackage{amsmath}
%PseudoCode
\usepackage{algorithm2e}

\titlespacing{\subsection}{0pt}{\parskip}{-3pt}
\titlespacing{\subsubsection}{0pt}{\parskip}{-\parskip}
\titlespacing{\paragraph}{0pt}{\parskip}{\parskip}
\newcommand{\figuremacro}[5]{
    \begin{figure}[#1]
        \centering
        \includegraphics[width=#5\columnwidth]{#2}
        \caption[#3]{\textbf{#3}#4}
        \label{fig:#2}
    \end{figure}
}

\lstset{
	escapeinside={/*@}{@*/}, language=C++,
	basicstyle=\fontsize{8.5}{12}\selectfont,
	numbers=left,numbersep=2pt,xleftmargin=2pt,frame=tb,
    columns=fullflexible,showstringspaces=false,tabsize=4,
    keepspaces=true,showtabs=false,showspaces=false,
    backgroundcolor=\color{white}, morekeywords={inline,public,
    class,private,protected,struct},captionpos=t,lineskip=-0.4em,
	aboveskip=10pt, extendedchars=true, breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941}
}

\thiswatermark{\centering \put(336.5,-38.0){\includegraphics[scale=0.8]{logo}} }
\title{\mytitle}
\author{\myauthor\hspace{1em}\\\contact\\Edinburgh Napier University\hspace{0.5em}-\hspace{0.5em}\mymodule}
\date{}
\hypersetup{pdfauthor=\myauthor,pdftitle=\mytitle,pdfkeywords=\mykeywords}
\sloppy
% #######################################
% ########### START FROM HERE ###########
% #######################################
\begin{document}
 \maketitle  
 
 \begin{abstract}
 	%An abstract is a 100-200 word summary of your report. It provides a brief %overview of the report by stating the purpose, defining the topic, summarising %the main sections of the report, and stating the conclusion or outcomes. An %abstract is usually written when you have completed the report
 \end{abstract}
 
 
 \pagenumbering{arabic} 
 %\textbf{Keywords -- }{\mykeywords}
 
% ########################################################################################################################
% ##################################################### INTRODUCTION #####################################################
% ########################################################################################################################
 \section{Introduction}
 The purpose of this report was to document the data structures and algorithms used during the process of designing and implementing the game Checkers (with English draughts rule set) with a command line interface in C\#.
 \newline
 He looks in depth at how and why he implemented the data structures that he did as well as explaining the logic behind the algorithms that were designed to solve the problems he faced whilst implementing the game.
 \newline
 There are 3 games modes included in this application:
 
 \begin{itemize}
 	\item Human vs Human
 	\item Human vs A.I.
 	\item A.I. vs A.I.
 \end{itemize}
 
 All game modes use the scoreboard implemented so that the players can observe the number of normal pieces and king pieces that are still present on the board for both players. The session score is also displayed in the scoreboard so that the players can play multiple games and determine the winner at the end of the current session.
 
 Whilst there is a human player, they will have access to the features Undo and Redo. He decided that during an A.I. vs A.I. these features would not be necessary. All game modes have access to the Replay feature as he considered it convenient to be able to replay full games regardless of whether a human player was involved in the game or not.
 \newline
 The A.I. vs A.I. game mode is the only game mode which imposes a draw as an end game condition. This was implemented to stop A.I. vs A.I. games from becoming excessive in length due to the A.I.'s movement being random.
 
 
 % ########################################################################################################################
 % ######################################################## DESIGN ########################################################
 % ######################################################################################################################## 
 \section{Design}   
 During this project he used a test-driven development approach in conjunction with an agile methodology. This is where the code is developed incrementally in sprints with the project only moving on to the next sprint once the testing of the work done, has been passed. He breaks it down into the 3 main areas which demonstrate the primary design choices that he made during development.
 
 
 \subsection{Interface}
 The application runs from the command line as this is what he was asked for in the coursework specification with the proviso that he could develop the application with a graphical interface at a later date. The introduction (Appendix \ref{appendix:a}) and winning screens (Appendix \ref{appendix:b} and Appendix \ref{appendix:c}) ASCII art were all created with an ASCII generator \cite{seyfferth}.
 
 
 \subsubsection{CLI Playing Board}
 To represent the board visually in the CLI, he used characters from the Windows character map application to create a custom design. The priority when designing the CLI board, was to ensure that it was easy to understand with good spacing to stop the screen from becoming cluttered.
 
 
 
 
 \subsection{Data Structures Used}
 He highlights the essential data structures used and explains why he used these specific data structures in the circumstances in which he did. The data structures used, assisted him in providing the features included in the application such as undo/redo and replay.     
 
 
 \subsubsection{2-Dimensional Array}   
 As the board for English draughts is an 8 x 8 chequered board, a 2 dimensional array[8,8] named \textit{positionsArray} is used to represent the board and store the current locations of the playing pieces. Each player starts with 12 normal pieces which are stored in \textit{positionsArray} as the strings 'X' and 'O'. To represent the kings, the strings stored are '|X|' and '|O|', the player can only acquire a king when they reach the opposite end of the board with a normal piece.
 The array is updated after every turn is made, then all the contents of each index in \textit{positionsArray}, are concatenated together separated by a comma into a single string with the last value either a 'X' or an 'O' to indicate who has just taken their turn. Every time the string is created it then gets popped on to a stack called \textit{undoStack} and enqueued in to a queue called \textit{replayQueue}.
 
 
 
 \subsubsection{Queue}
 The queue data structure was selected for the replay feature as it uses the First-In-First-Out method for storing and retrieving information. This meant that he could add (enqueue) the string comprised of the current playing piece positions to the back of the queue after every turn. When the user selects to replay the current match, the application enters a loop which will iterate through all the string values stored in the queue and display them on the board. A pause has been added to the loop, so that the replay can be followed by the human eye.
 
 
 \subsubsection{Stack}
 The stack data structure is used to aid the implementation of both the undo and redo features. A stack uses the Last-In-Last-Out method for storing and retrieving information, which meant he could synergise the stacks together, to provide effective undo and redo features.
 \newline
 Both the queue and stack data structures selected offer improved performance over the other data structures available which could perform similar tasks but would be slower, such as an array or a list.
 
 
 \subsubsection{List}
 The list data structure is used twice in the application, both times it has been used as the number of values it could store at any one time will vary from move to move. He decided that as the size of the data structure needed could not accurately be predicted a list would be the best option as it adjusts its size dynamically. This removes the potential for an out of range exception when accessing the data structure selected.
 
 
 
 \subsection{Algorithms Used}
 The application has many algorithms which when all combined help to produce a robust version of the game Checkers. He details the algorithms that are essential for the application to simulate games of Checkers.
 
 \subsubsection{Valid Move Check}
 If a player has no valid moves available, then they lose the game. To enforce this rule, he used a valid move check algorithm. The valid move check takes place before the user has entered the Y and X co-ordinates of the piece they wish to move. The method \textit{AreThereAnyValidMoves()} is called (from the Player class) which returns a Boolean value depending on whether the current player has any available move to play or not.
 \newline
 The algorithm starts by:  
 
 
 \begin{itemize}
 	\item Looping through the textit{positionsArray} checking every index for a string that matches the current players normal piece or a king piece.  
 	\item Once a piece is found, the algorithm then checks if that piece can capture an opponent's piece.
 	\item If not, then the algorithm checks if the piece can complete a successful move. 
 	\item If after all the current players pieces have been checked and neither the capture or move checks return true, then the current player loses the game as there are no available moves to be made. 
 \end{itemize}
 
 
 
 
 \subsubsection{Force Capture} 
 In the English draughts rule set if there is a capture available the player must make that move, unless there are multiple captures where the player can choose which capture to make. After the player has entered the Y and X co-ordinates of the piece they want to move and the tile they want to move the piece to, the method \textit{ForcedCaptureCheck()} is called (from the Player class).
 \newline
 This algorithm starts in the same way as the valid move check algorithm does by:    
 
 \begin{itemize}
 	\item Looping through the \textit{positionsArray} checking every index for a string that matches the current players normal piece or a king piece.
 	\item When a piece is found, the algorithm checks if that piece can capture an opponent's piece.
 	\item If that piece can capture an opponent's piece, the algorithm takes the Y and X co-ordinates and concatenates them together storing the value in a list called \textit{listOfForcedMoves}.
 	\item Once the algorithm has looped through all the array, storing all the potential moves the current player can make.
 	\item The algorithm takes the Y and X co-ordinates that the player entered as the values for the piece they want to move, concatenates them together then compares that value with the values stored on the list \textit{listOfForcedMoves}.
 	\item If the co-ordinates entered match any of the values stored on the list, then that is an allowed move.
 	\item The algorithm passes the co-ordinates to the method \textit{PlayerMove()} which allows the move to continue.
 	\item If the co-ordinates entered do not match any of the values stored on the list, then the move the player wants to make is not allowed.
 	\item A message informs the player that they must play the capture move available to them.
 \end{itemize} 
 
 
 \subsubsection{A.I.}    	
 
 In this application he has included the ability to play against an A.I. player or to watch A.I. vs A.I. games. The A.I. implemented, is from his own design and as this is the first version of the A.I. he concentrated on making sure the logic was sound and that the A.I. class integrated well with the application to provide a good platform from which to improve the A.I. in the future.
 
 The A.I. algorithm can be found in the method \textit{GetMove()} in the A.I. class. The algorithm works by first:  	
 
 
 \begin{itemize}
 	\item Checking which player's turn it currently is then adding one to that players counter.    		
 	\item Then calculating the modulus of that counter and if the value equals 0 then the application will enter the path of the algorithm which searches for the current player's pieces starting from the back of the board, ending at the front. 
 	\item If the value of the modulus calculation does not equal 0 then the application will enter the path of the algorithm which searches for the current player's pieces in the opposite direction from the previous path.
 	\item For both paths, the algorithm will loop through \textit{positionsArray} looking for a king piece which can capture an opponent's piece. If one is found that move will be made and if there are no kings which can make a capture the algorithm will move on. 
 	\item The algorithm repeats the previous step except this time it searches for a normal piece which can capture an opponent's piece. If the search conditions are not met, the algorithm moves on to the next step.
 	\item Where the algorithm loops through \textit{positionsArray} searching for a king piece that has at least one move available from the four potential directions. If the king only has one move the algorithm will make that move, however if there are two or more moves available for that king the algorithm will select at random which move to make. If there are no available moves, the algorithm will move on to the next step.
 	\item The algorithm loops through \textit{positionsArray} seeking a normal piece, once it finds one the algorithm checks if the normal piece can move in either of its 2 potential directions. If it can the algorithm will make that move.
 	\item The algorithm will always find a move to play as before every move there is a valid move check which must return true for the application to reach this part of the A.I. code.    		
 \end{itemize}
 
 
 
 
 
 
 
 \subsubsection{Win / Draw Conditions}
 For a game to end, certain conditions must be met which result in either one of the players winning the match or a draw between the two A.I. players. This application has two algorithms which handle potential game ending, checks. The first algorithm checks every turn if a player has won the game.
 \newline
 The algorithm does this by:
 
 \begin{itemize}
 	\item Calling the method \textit{IsThereAWinner()} from the TheBoard class.
 	\item The method adds the value for each players kings and normal pieces together, then checks if the total equals 0.
 	\item If either player is left with 0 playing pieces, then they have lost the game.
 	\item The winning screen is shown indicating which player has won.
 \end{itemize}
 
 The second algorithm has only been implemented in the A.I. vs A.I. game mode. It checks every turn if the game is a draw.
 \newline
 This algorithm works by:
 
 \begin{itemize}
 	\item Calling the method \textit{IsItADraw()} from the AI class.
 	\item This method checks if the variable \textit{howManyMovesWithoutACapture} is equal to 20.
 	\item The variable \textit{howManyMovesWithoutACapture} acts as a counter and increases by 1 every time either player makes a move but not a capture.
 	\item The counter is reset to 0 every time there is a capture by either player.
 	\item This means that if both A.I. players go a combined amount of 20 turns without a capture, the game is considered a draw.
 \end{itemize}
 
 
 
 
 
 
 
 
 % ########################################################################################################################
 % ##################################################### ENHANCEMENTS #####################################################
 % ######################################################################################################################## 
 \section{Enhancements}
 During the implementation phase of this project, these were the features that he considered but either deemed to be too time intensive to implement and test before the submission date or he implemented a simplified version. These features may be implemented or improved as part of the software's evolution in the future.
 
 
 \subsection{Export and Import full game replays}
 The ability to export and import game replays, to and from a file format such as comma-separated values (.CSV).     
 The application would convert the strings that are currently used to store the positions of all the playing pieces each turn, into the Portable Draughts Notation which is the standardised notation for recording games of checkers. 
 
 
 \subsection{Multiple rules sets available}
 Allowing the users to select which game rules they would like to play for the current session. Examples of different rule sets that could of been implemented:
 
 
 \subsubsection{International Checkers}
 The size of the board would have to be increased for International Checkers as the standard board size is 10 x 10 with 20 playing pieces per player. The 'flying kings' rule where the king has increased range of movement and the ability for 'normal' pieces to capture opponent pieces by jumping backwards would both require alterations to the movement and capturing logic.    
 As it is a rule that the move which captures the highest number of opponent pieces must always be taken, a form of scoring system would need to be introduced to ensure that only the highest scoring move is taken by the player or A.I.
 
 
 \subsubsection{Brazilian / Italian Checkers}
 Both of these rule sets are only slight modifications from either English draughts or International checkers. Brazilian checkers uses the same rule set as International checkers, but these games are played on a 8 x 8 board whereas Italian checkers while played on the same size of board with a similar rule set to English draughts, there is the additional rule that 'normal' pieces cannot capture king pieces.
 
 
 \subsubsection{Suicide Checkers}
 Suicide checkers, which is also known as Losing draughts, is a variation of checkers where the objective of the game is to lose all your playing pieces before your opponent can lose all of their pieces. The winner being the first player left with 0 checkers or no available moves to make. 
 
 
 \subsection{Improved AI} 
 The current A.I. could be improved by implementing an algorithm which would search for each available move assigning it a score, based on set criteria. The algorithm would then select and play the move with the highest score.    
 The current A.I. only searches either one or two tiles away diagonally before making an available move. Increasing the search distance to 3 or 4 tiles from the selected piece would survey a larger portion of the board each move and would allow a score based algorithm to adapt sooner to the opponents moves.
 
 
 \subsection{Player Leader Board} 
 A player leader board would have only been available in the Human vs A.I. game mode and would have used the number of moves made to determine the score. This would have allowed for the comparison between multiple games and the ability to rank the scores. The application would have had to write to and read from a .CSV file where the leader board information would have been stored so that it wasn't lost when the application was closed.
 
 
 
 
 
 
 
 
 
 % ########################################################################################################################
 % ################################################# CRITICAL  EVALUATION #################################################
 % ######################################################################################################################## 
 \section{Critical Evaluation}
 %Describe the features that I felt worked well or poorly and why I thought this.
 
 % game is fit for purpose / follows rules/ stability from testing results
 
 % ai vs ai game mode works well, varied results which means not the same winner all the time
 
 
 % ########################################################################################################################
 % ################################################# PERSONAL  EVALUATION #################################################
 % ######################################################################################################################## 
 \section{Personal Evaluation}
 \subsection{Challenges Faced}
 As the project has now been completed there are some areas which, with the wisdom of hindsight he would have approached differently. 
 \newline 
 He would have liked to of started the project earlier than when he did. This would have given him more time to implement extra features and to test the whole application thoroughly. The extra time would have allowed him to better refine the C\# code into a more object orientated style of implementation. In the future he will take a more active approach to initially planning projects and then adhering to the time frames for each task.
 \newline
 He would have liked to of taken the initial advice from the lecturer about implementing the application with a CLI. While implementing the application with a GUI, he encountered a problem with threading. The GUI board would not update the current playing piece positions until the current thread had ended. This meant that he was unable to implement the replay and A.I. features inside a loop as he had visualised with the moves being made one after the other with no input from the user. He could implement both features, but it meant having to use a button to step through each move which he considered unsatisfactory. This left him with only two options available of either learning about threading in C\# or converting the GUI implementation to a CLI implementation. Due to time constraints he opted for the conversion.
 \newline
 
 \subsection{Knowledge Gained}
 Before this project there were some areas in which he had very little or no experience with. This meant that he was in some instances having to learn during the implementation.
 \newline 
 Having only studied the stack and queue as abstract data structures prior to this project. Simply implementing them in classroom exercises without real context. He had never implemented either in the real working environment in which they excel. He thinks that by using them to deliver the undo, redo and replay features he now has a better appreciation of the stack and queues advantages as well as their limitations.
 \newline
 The switch from GUI to CLI brought its own set of challenges as he had never used the console in C\# for implementing a game with a CLI before. Going from a more visual interface with specified buttons to a menu based interface using characters only was testing yet he believes that having now done so, he gained knowledge working with the less intuitive CLI whilst trying to make it as user friendly as possible.
 \newline
 Having never encountered version control or the typesetting system LaTeX before, he had to make it a priority to learn the basic functionality of both these requirements for this project.
 \newline
 Having now used version control, he is able to recognise the advantages of using such a system for updating, sharing and keeping track of software development projects. He used GitHub to host his repository with the GUI application SourceTree enabling him to commit / push updates to his repository. Although it was only himself who was making updates to the source code he was still able to appreciate that version control would be more beneficial if he were part of a group working on the same project having to access the same files.
 \newline
 He believes that LaTeX was unnecessarily complicated for the purpose in which he used it. He would have preferred to of spent more time on the project than trying to decipher from the multitude of convoluted ways in which to link from the body of the report to an appendix. He does acknowledge that he believes the software is a very powerful tool when using it for maths based content and that his opinion of the software is likely skewed due to experiencing a high learning curve. 
 \newline
 
 \subsection{Performance}
 He believes from a black box perspective he has done a good job. He considers the presentation excellent for a CLI game with the right amount of information for the user to process at any given time without them feeling overwhelmed. He feels the implementation contains all the features asked for in the coursework specification with a couple of his own additions such as the session scoreboard and playing piece counter.
 \newline
 He was happy with the data structures he selected and how he implemented them as close as possible to follow the behaviours of their abstract counterpart.
 \newline
 He considers the testing done confirms that the application is robust and designed well with appropriate consideration for exception and error handling.
 \newline
 In his view the weakest part of the project was his time management and the style of the implemented code. Both issues go hand in hand as he was unable to improve his code due to a lack of time. He concedes that there is a lot of room for improvement with the code, recognising that there is a clear improvement in the coding syntax and efficiency from when he implemented the player class to when he implemented the A.I. class.
 
 
 
   






\onecolumn


 \newpage
	\bibliographystyle{ieeetr}
	\bibliography{references} 

 	\appendix
 
 \newpage
 \section{Appendix A}
 \label{appendix:a}
 \begin{figure}[H]
 	\centering 	
 	\includegraphics[scale=0.8]{Intro}
 	\caption{Introduction - ASCII art}		
 \end{figure}
 %
 %
 %
 \newpage
 \section{Appendix B}
  \label{appendix:b}
 \begin{figure}[H]
 	\centering
 	\includegraphics[scale=0.8]{XWin}
 	\caption{Player X winning screen - ASCII art}
 \end{figure}
 %
 %
 %
 \newpage
 \section{Appendix C}
  \label{appendix:c}
 \begin{figure}[H]
 	\centering	
 	\includegraphics[scale=0.8]{OWin}
 	\caption{Player O winning screen - ASCII art}		
 \end{figure}
 %
 %
 %
 \newpage
 \section{Appendix D}
  \label{appendix:d}
 \begin{figure}[H]
 	\centering	
 	\includegraphics[scale=0.8]{RunOne500}
 	\caption{Run 01 - 500 A.I. vs A.I. played}		
 \end{figure}
 %
 %
 %
 \newpage
 \section{Appendix E}
  \label{appendix:e}
 \begin{figure}[H]
 	\centering
 	\includegraphics[scale=0.8]{RunTwo500}
 	\caption{Run 02 - 500 A.I. vs A.I. played}
 \end{figure}
 %
 %
 %
 \newpage
 \section{Appendix F}
  \label{appendix:f}
 \begin{figure}[H]
 	\centering	
 	\includegraphics[scale=0.8]{RunOne1000}
 	\caption{Run 01 - 1000 A.I. vs A.I. played}		
 \end{figure}
 %
 %
 %
 \newpage
 \section{Appendix G}
  \label{appendix:g}
 \begin{figure}[H]
 	\centering
 	\includegraphics[scale=0.8]{RunTwo1000}
 	\caption{Run 02 - 1000 A.I. vs A.I. played}
 \end{figure}
 %
 %
 %
 \newpage
 \section{Appendix H}
  \label{appendix:h}
 \begin{figure}[H]
 	\centering	
 	\includegraphics[scale=0.8]{RunOne2500}
 	\caption{Run 01 - 2500 A.I. vs A.I. played}		
 \end{figure}
 %
 %
 %
 \newpage
 \section{Appendix I}
  \label{appendix:i}
 \begin{figure}[H]
 	\centering
 	\includegraphics[scale=0.8]{RunTwo2500}
 	\caption{Run 02 - 2500 A.I. vs A.I. played}
 \end{figure}   
 %
 % 
 %
\end{document}
 
 
 
 
	
	

		
